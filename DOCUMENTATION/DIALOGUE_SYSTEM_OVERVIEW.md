# Dialogue System Overview

This document outlines the key components, flow, and mechanisms involved in the LLM-powered dialogue system.

> ⚠️ **CURRENT STATUS: FUNCTIONAL WITH RECENT FIXES** ⚠️  
> The dialogue system has been updated to fix issues with stuck conversations and improve BeepSpeak text handling.

## 1. Key Components

### Scripts

*   **`DialogueControl.cs` (`Assets/Scripts/NPCs/`)**:
    *   Attached to the main Dialogue UI Canvas/GameObject.
    *   Manages the activation and deactivation of the dialogue UI (including animations).
    *   Handles game state transitions (`GameState.DIALOGUE` <-> `GameState.DEFAULT`).
    *   Acts as the entry point when player interacts with an NPC.
    *   Calls `LLMCharacter.Load()` on activation (if save exists) and `LLMCharacter.Save()` on deactivation.
    *   Calls `LLMDialogueManager.InitializeDialogue()` and `ResetDialogue()`.
    *   Provides methods (`DisplayNPCDialogueStreaming`) for updating the UI text, potentially integrating with `BeepSpeak.cs`.
    *   Handles Escape key input to deactivate dialogue.
    *   Calls `LLMCharacter.CancelRequests()` indirectly via `ResetDialogue` when deactivated.

*   **`BaseDialogueManager.cs` (`Assets/Scripts/Dialogue/`)**:
    *   Abstract base class providing core dialogue logic.
    *   Holds reference to the current `LLMCharacter`.
    *   Manages response processing state (`isProcessingResponse`).
    *   Receives LLM responses via the `HandleReply` callback.
    *   **Processes Streaming Text:** In `HandleReply`, uses `currentResponse.Clear(); currentResponse.Append(reply);` to correctly handle streaming text chunks from the LLM (fixed text duplication issue).
    *   **Parses Function Calls:** Checks for `\nACTION:` or `[/ACTION]:` delimiter in `HandleReply`. If found, sets `actionFoundInCurrentStream` flag, splits dialogue from action string, and buffers the function call for later processing.
    *   **Handles Function Calls (`ProcessFunctionCall`):**
        *   `stop_conversation`: Calls `DialogueControl.Deactivate()`.
        *   `reveal_node`: Extracts `node_id` parameter using `ExtractNodeId` and calls `GameControl.coreConstellation.DiscoverNode(nodeId)`.
    *   Handles cancellation via `ResetDialogue` which calls `LLMCharacter.CancelRequests()`.
    *   Defines abstract methods for UI interaction (`EnableInput`, `DisableInput`, `UpdateDialogueDisplay`).
    *   Provides coroutines `ProcessActionAfterBeepSpeak` and `EnableInputAfterBeepSpeak` to wait for BeepSpeak to finish before acting.

*   **`LLMDialogueManager.cs` (`Assets/Scripts/Dialogue/`)**:
    *   Concrete implementation inheriting from `BaseDialogueManager`.
    *   Likely attached to the same GameObject as `DialogueControl` or a child object within the Dialogue Canvas prefab.
    *   Holds references to specific UI elements (`TMP_InputField`, `TMP_Text` for player/NPC dialogue, `Button`).
    *   Handles player input submission (`OnSubmitClicked`) and sends it to `LLMCharacter.Chat()`.
    *   Implements `UpdateDialogueDisplay` to forward text to `DialogueControl` (for BeepSpeak/UI).
    *   Implements `EnableInput`/`DisableInput` to manage UI interactability.
    *   Registers itself with `DialogueControl`.

*   **`CharacterPromptGenerator.cs` (`Assets/Scripts/Characters/`)**:
    *   Static class responsible for creating the detailed system prompt string passed to the `LLMCharacter`.
    *   Uses data from `MysteryCharacter` and the overall `MysteryMetadata` (context, title).
    *   Includes specific instructions for the LLM on how to format function calls (`\nACTION: ...` or `[/ACTION]:...`) and when to trigger revelations based on player input or evidence presentation.

*   **`LLMCharacter.cs` (LLMUnity Package)**:
    *   The core component interfacing with the actual LLM backend.
    *   Receives the system prompt generated by `CharacterPromptGenerator`.
    *   Handles the `Chat()` requests, sending input + history + prompt to the LLM.
    *   Provides the streaming response via the `HandleReply` callback.
    *   Provides `Load()` and `Save()` methods for conversation history/cache.
    *   Provides `CancelRequests()` to attempt stopping ongoing generation.

*   **`MysteryConstellation.cs` (`Assets/Scripts/CoreControl/MysteryParsing/Constellation/`)**:
    *   Contains the `DiscoverNode(string nodeKey)` method, which is the target for the `reveal_node` function call. It handles the logic for unlocking nodes in the game's mystery graph.

*   **`BeepSpeak.cs` (`Assets/DialogueSFX/`)**:
    *   Optional component referenced by `DialogueControl`.
    *   Used to display dialogue text with a typing effect and associated audio feedback. `DialogueControl.DisplayNPCDialogueStreaming` updates its text.
    *   Manages a typing coroutine (`typingCoroutine`) that controls the text display pacing.
    *   The `IsPlaying` property (returns `typingCoroutine != null`) is used by `DialogueControl` to determine when text animation is complete.

### Scene Objects / Prefabs

*   **Dialogue Canvas GameObject**: The main UI canvas holding all dialogue elements. Activated/deactivated by `DialogueControl`. Contains the `DialogueControl` script and likely the `LLMDialogueManager`.
*   **NPC Dialogue Text (TMP_Text)**: UI element displaying the NPC's response. Managed by `LLMDialogueManager` via `DialogueControl`.
*   **Player Dialogue Text (TMP_Text)**: UI element displaying the player's last input. Managed by `LLMDialogueManager`.
*   **Input Field (TMP_InputField)**: Where the player types their dialogue. Managed by `LLMDialogueManager`.
*   **Submit Button (Button)**: Button to send player input. Managed by `LLMDialogueManager`.
*   **NPC Prefab**: Contains the `Character.cs` component which links the physical NPC to its corresponding `LLMCharacter` instance managed by `CharacterManager`. Player interaction with the NPC likely triggers `DialogueControl.Activate()`.

## 2. Dialogue Flow

1.  **Activation**: Player interacts with an NPC (e.g., presses 'E'). The NPC's interaction logic calls `DialogueControl.Activate(npcGameObject)`.
2.  **Character Setup**: `DialogueControl` gets the `Character` component, retrieves the associated `LLMCharacter` instance, and calls `llmDialogueManager.SetCharacter()`.
3.  **Load History**: `DialogueControl` checks if a save file exists for the character and calls `await llmCharacter.Load()` if it does.
4.  **UI Activation**: `DialogueControl` activates the Dialogue Canvas and plays an activation animation. `GameControl` state is set to `DIALOGUE`.
5.  **Initialization**: Once the animation is complete, `DialogueControl` calls `llmDialogueManager.InitializeDialogue()`, which enables the input field.
6.  **Player Input**: Player types in the `InputField` and clicks `Submit` or presses Enter.
7.  **Send to LLM**: `LLMDialogueManager.OnSubmitClicked` disables input, clears previous response data, and calls `llmCharacter.Chat(userInput, HandleReply, OnReplyComplete)`.
8.  **LLM Response (Streaming)**: `LLMCharacter` sends the request to the LLM. As response chunks arrive, the `HandleReply` callback in `BaseDialogueManager` is invoked.
9.  **Response Parsing (`HandleReply`)**:
    *   **CRITICAL FIX:** Previous duplication issues were fixed by changing `currentResponse.Append(reply)` to `currentResponse.Clear(); currentResponse.Append(reply)`. Each LLM chunk contains the complete response so far, not just new content.
    *   Checks for delimiter (`\nACTION:` or `[/ACTION]:`).
    *   If found, sets the `actionFoundInCurrentStream` flag, splits the text into dialogue (text before delimiter) and action (text after delimiter).
    *   Buffers the function call for later with `bufferedFunctionCall = functionCallPart`.
    *   Updates the display with ONLY the dialogue part via `UpdateDialogueDisplay(dialoguePart)`.
    *   If no delimiter found, updates the display with the complete accumulated text.
10. **UI Update (`UpdateDialogueDisplay`)**: `LLMDialogueManager` forwards the accumulating dialogue text to `DialogueControl`, which updates the NPC text UI (potentially via BeepSpeak).
11. **Stream Complete (`OnReplyComplete`)**: Called by `LLMCharacter` when the full response is received. Checks if an action was buffered:
    *   If buffered, starts `ProcessActionAfterBeepSpeak` coroutine to wait for dialogue text animation to finish, then process the action.
    *   If no action, starts `EnableInputAfterBeepSpeak` coroutine to wait for dialogue animation to finish, then re-enable input.
12. **Function Execution (`ProcessActionAfterBeepSpeak` -> `ProcessFunctionCall`)**: If an action was parsed:
    *   `stop_conversation`: `DialogueControl.Deactivate()` is called.
    *   `reveal_node`: `node_id` is extracted, `GameControl.coreConstellation.DiscoverNode(nodeId)` is called.
13. **Input Re-enabling (`EnableInputAfterBeepSpeak` -> `EnableInput`)**: After BeepSpeak finishes, input is re-enabled if dialogue is still active.
14. **Deactivation (Escape Key)**: Player presses Escape. `DialogueControl.Update()` detects this and calls `Deactivate()`.
15. **Deactivation (Function Call)**: `stop_conversation` function call triggers `DialogueControl.Deactivate()`.
16. **Deactivation Process (`DeactivateDialogue` Coroutine)**:
    *   Calls `llmDialogueManager.ResetDialogue()` which calls `llmCharacter.CancelRequests()` and stops BeepSpeak typing. Waits for this task.
    *   Calls `llmCharacter.Save()` to save conversation history. Waits for this task.
    *   Immediately plays deactivation animation (no delay).
    *   Deactivates Dialogue Canvas.
    *   Resets `GameControl` state to `DEFAULT`.

## 3. Function Calling Details

*   **Prompting**: `CharacterPromptGenerator` explicitly tells the LLM the available functions (`reveal_node`, `stop_conversation`), their parameters, and the **exact** output format (`\nACTION: function_name(param=value)` on a new line after dialogue, or alternatively `[/ACTION]: function_name(param=value)`). It also links revelation triggers to the `reveal_node` action.
*   **Parsing**: `BaseDialogueManager.HandleReply` checks for both `\nACTION:` and `[/ACTION]:` delimiters using `IndexOf`. When found, it sets the `actionFoundInCurrentStream` flag and extracts both the dialogue part (before the delimiter) and the function call part (after the delimiter). The function call is buffered for later processing.
*   **Execution**: After BeepSpeak finishes, `ProcessActionAfterBeepSpeak` calls `ProcessFunctionCall` which uses `StartsWith` to identify the function name and then calls the relevant game logic (`DialogueControl.Deactivate` or `MysteryConstellation.DiscoverNode`).

## 4. State Management

*   **Game State**: `GameControl.currentState` is set to `GameState.DIALOGUE` during activation and back to `GameState.DEFAULT` during deactivation. Player movement and other systems likely check this state.
*   **Dialogue UI State**: `DialogueControl` manages the active state of the canvas and UI animations (`isTransitioning`).
*   **LLM Response State**: `BaseDialogueManager.isProcessingResponse` flag prevents sending new requests while waiting for a reply. `actionFoundInCurrentStream` flag prevents processing additional text chunks after an action has been found in the current stream.
*   **BeepSpeak State**: `BeepSpeak.typingCoroutine` tracks the active typing animation. `IsPlaying` property returns whether this coroutine is active.
*   **Input State**: `LLMDialogueManager` enables/disables the input field and submit button via `EnableInput`/`DisableInput`.

## 5. Dependencies & Interactions

*   `Player Interaction` -> `NPC` -> `DialogueControl.Activate`
*   `DialogueControl` -> `LLMCharacter` (Load, Save)
*   `DialogueControl` -> `LLMDialogueManager` (SetCharacter, InitializeDialogue, ResetDialogue)
*   `LLMDialogueManager` -> `LLMCharacter` (Chat)
*   `LLMCharacter` -> `BaseDialogueManager` (HandleReply, OnReplyComplete callbacks)
*   `BaseDialogueManager` -> `LLMDialogueManager` (UpdateDialogueDisplay, EnableInput, DisableInput - abstract calls)
*   `BaseDialogueManager` -> `DialogueControl` (Deactivate via ProcessFunctionCall)
*   `BaseDialogueManager` -> `MysteryConstellation` (DiscoverNode via ProcessFunctionCall)
*   `LLMDialogueManager` -> `DialogueControl` (DisplayNPCDialogueStreaming)
*   `DialogueControl` -> `BeepSpeak` (Optional: StartDialogue, UpdateStreamingText)
*   `BaseDialogueManager` -> `BeepSpeak` (Indirectly waits for `IsPlaying` to become false via `DialogueControl.IsBeepSpeakPlaying`)

## 6. Known Issues

### Fixed: Input Box Not Re-enabling (April 2025 Update)
This issue has been fixed by:
1. Enhancing `BeepSpeak.ProcessTyping()` with intelligent handling of incomplete word boundaries:
   - Now detects when LLM has stopped sending new text for 1.5 seconds
   - Forces completion of partial words without waiting for word boundaries
   - Properly resets `typingCoroutine` to null on completion
   - Adds detailed logging of typing completion state

2. Adding safety mechanisms to dialogue waiting coroutines:
   - 5-second timeout in `EnableInputAfterBeepSpeak` to ensure input is eventually re-enabled
   - Automatic StopTyping call if timeout occurs
   - Immediate function call processing after BeepSpeak finishes (removed delay)

These changes ensure that even if the LLM sends incomplete sentences or words without proper boundaries, the typing animation will still complete, and the input box will be re-enabled or the conversation will properly end with function calls.

### Previously Fixed: Text Duplication
Initially fixed by changing `currentResponse.Append(reply)` to `currentResponse.Clear(); currentResponse.Append(reply)` in `BaseDialogueManager.HandleReply`. LLM response chunks contain the complete response so far, not just new content, so appending created duplicated text.

### Performance Concerns
Some users report slow response when opening or closing dialogue. This may be due to:
- Long animations
- File I/O operations (Save/Load)
- LLM operations affecting framerate

*Timing diagnostics have been added with [TIMEDBG] tags to measure stages of activation/deactivation.*

## 7. Debugging Tools

### Input Flow Diagnostics
Debug logs with `[INPUTDBG]` tags have been added to track the following:
- When `OnReplyComplete` is called and if the `isProcessingResponse` flag is accurate
- Whether `EnableInputAfterBeepSpeak` is started and waiting correctly
- The state of `BeepSpeak.typingCoroutine` during waiting
- When `EnableInput` is finally called or skipped and why

### Performance Timing
Debug logs with `[TIMEDBG]` tags have been added to measure:
- Total time spent in `Activate` and `Deactivate`
- Animation times for dialogue UI activation/deactivation
- Time spent initializing dialogue
- Time spent saving/loading conversation history
